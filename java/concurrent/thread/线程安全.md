# 一 概述：
## (1)定义:
- 当多个线程并发访问一个对象时，如果不用考虑这些线程在运行时环境下的调度和交替执
行，也不需要额外的同步，或在调用方不用进行任何协调，调用这个对象的行为都可以获得
正确的结果(Java Concurrency In Practice).

## (2)种类(安全强度由高到低):
- 不可变: final修饰的基本类型；若是对象，则需保证对象的行为不会对其状态产生任何>影响(例如String).
- 绝对线程安全：满足线程安全的定义，但Java API中标记是线程安全的类大部分都不是绝
对线程安全.
- 相对线程安全：通常意义的线程安全，需保证对该对象单独的操作是线程安全，但对于一
些特定顺序的连续调用，可能需要额外的同步措施保证调用的正确性.Java中大部分线程安>全类属于该类型，例如：Vector、HashTable、Collections的synchronizedCollection()方
法包装的集合.
- 线程兼容：对象本身并不是线程安全，需要在调用端使用一些同步手段来保证对象在并发
环境中可以安全的调用.通常所说的线程不安全属于该类.
- 线程对立：无论调用端是否采取同步措施，都无法在多线程环境中并发使用.例如：Thread类的suspend()和resume().

# 二 线程安全实现方法：
## (1)互斥同步(悲观策略):
- 多线程并发访问共享数据时保证只有一个线程可以访问.
- 例如：synchronized关键字和java.util.concurrent包中的显式锁.
- 备注：互斥同步主要问题是进行线程阻塞和唤醒带来的性能开销.

## (2)无阻塞同步：
- 随着硬件指令集的发展，基于冲突检测的乐观并发策略可以使用，即先执行操作，若没有
线程争用共享数据则操作成功；若有共享数据争用，则产生冲突，此时再采取其他的补偿措
施.
- 硬件需保证操作和冲突检测这两个步骤具有原子性，即一个从语义上需要多个操作的性能
通过一条处理器指令就可以完成,例如：比较并交换(CAS)等.
- sun.misc.Unsafe类提供调用这些硬件指令的接口，都是native方法.

## (3)无同步方案：
- 可重入代码：可重入一定是线程安全的.
- 线程本地存储.

# 三 非阻塞同步算法：
## (1)概述:
- 借助底层的原子机器指令(例如:CAS)来替代锁确保数据在并发访问中的一致性.
- 使多个线程在竞争相同的数据时不会发生阻塞, 能可以在更细粒度上进行协调, 并极大地减少调度开销.
- 非阻塞算法不存在死锁和其它活跃性问题.