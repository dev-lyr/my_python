# 一 概述:
## (1)相关概念:
- 泛型类或接口: 声明中带有一个或者多个类型参数的类或接口.
- 原生态类型(raw type): 即不带任何实际类型参数的泛型名称.如List<E>的原生态类型为List.
- 原则: 错误应该早发现, 最好是编译时发现.

## (2)effective 泛型:
- 不要在新代码中使用原生态类型, 原生态类型异常是在运行时产生, 泛型是**编译期**, 早发现早纠正.
- 数组和泛型最好不要混用，**数组是协变的(covariant), 若sub是super的子类型, 则sub[]是super[]子类型, 而`list<sub>`和`list<super>`没有关系.** 数组是具体化的(reified)的, 在运行时才知道并检查元素类型约束, 若不满足会抛出ArrayStoreException; 泛型是通过擦除(erasure)来实现, 在编译期强化类型信息, 在运行时擦除元素的类型信息.
- 优先使用泛型和泛型方法.
- 使用泛型比类型转换更安全和容易.

## (3)备注:
- 可以使用参数化的类型以允许插入任意对象，如: `List<Object>`.
- C++中子类复制到父类类型的容器中，子类自身的信息会被切除，强制转型会报错.
- Java SE5之前，当对象放到容器中时，这个对象会被向上转型为Object，会丢失类型信息，当需要使用时需向下转回正确类型. Java SE5之后可以直接使用.
  
# 二 语法:
## (1)概述:
- 泛型类: `public class VmImpl <T>{}`
- 泛型接口: `public interface VM <T> {public <T> T getT();}`
- 泛型方法: `public <T,V> T getT(T t, V v);    //泛型方法.`

## (2)类型变量限制:
- `<T extends MyClass>`

## (3)通配符:
- `?`: 无界通配符.
- `<? extends T>`: 与(2)类似.
- `<? super T>`: 限制超类型.

## (4)备注:
- 对于任何类型type1和type2，List<type1>和List<type2>没关系.
- **通配符不是类型变量**.

# 三 擦除(erased):
## (1)概述:
- **对于JVM而言，没有泛型类型对象，所有对象都是普通类**.
- 无论何时定义一个泛型类型，都自动提供一个相应的原始类型(raw type).
- 擦除: 擦除类型变量，并替换为限定类型(无限定类型用Object).
- Java泛型与C++泛型区别: c++中模板的实例化会产生不同类型，导致模板代码膨胀.

## (2)类型擦除带来的限制:
- 不能用基本类型实例化类型参数.
- 运行时状态查询只适用于原始类型.
- 不能创建参数化类型的数组.
- 不能实例化类型变量.例如: 不能在方法中使用T a = new T().
- 不能泛型类的静态域或静态方法使用类型变量，例如: 不允许出现静态类型成员变量.
- 不能抛出或捕获泛型类的实例.
- 注意类型擦除带来的冲突.
