# 一 概述:
## (1)经验:
- 对象主要分配在Eden空间上, 若启动了本地线程分配缓存, 则优先分配到线程的TLAB上.
- 少数情况对象直接进入老年代.
- 分配原则并不固定取决于使用哪一种垃圾收集器组合, 以及虚拟机和内存相关参数设置.

# 二 对象优先在Eden分配:
## (1)概述:
- 大多数情况下, 对象直接在新生代的Eden区中分配, 当Eden没有足够空间时, 则虚拟机发起一次Minor GC.

# 三 大对象直接进入老年代:
## (1)概述:
- 大对象指需要大量连续内存空间的对象, 例如: 常字符串或数组.
- 将大对象直接分配到老年代原因是避免在Eden和两个Survivor之间大量的 内存复制.
- 经常出现大对象容易导致还有很多内存空间时就需要提前垃圾回收从而获得足够的连续空间.

## (2)相关设置:
- -XX:PretenureSizeThreshold参数, 大于这个设置值的对象直接在老年代分配.

# 四 长期存活对象将进入老年代:
## (1)概述:
- 虚拟机给每个对象定义一个年龄计数器, 当对象在Eden经历第一次Minor GC后仍然存活, 并且被移到Survivor空间中，此时对象年龄设置为1. 对象在Survivor熬过一次Minor GC则年龄增加1, 到达一定程度(默认为15)，则该对象将直接晋升到老年代.
- 可通过-XX:MaxTenuringThreshold值设置年龄阀值.

## (2)动态对象年龄判断:
- 为了适应不同程序的内存情况, 虚拟机不总要求对象年轻到达MaxTenuringThreshold才会晋升到老年代.
- 若Survivor空间中相同年龄所有对象大小的总和大于Survivor空间的一半, 则年龄大于或等于该年龄的对象可以直接进入老年代.

# 五 空间分配担保:
## (1)概述:
- 在发生Minor GC之前, 虚拟机会检查老年代的连续空间对于新生代对象总大小或者历次晋升的平均大小则进行Minor GC; 否则直接进行Full GC.
- 由于新生代使用复制收集算法, 使用其中一个Survivor空间作为备份, 当出现大量对象在Minor GC后仍然存活的情况时，把Survivor无法容纳的对象直接进入老年代,若老年代也不足时就会触发Full GC.

## (2)备注:
- HandlePromotionFailure参数在新版本已不使用.