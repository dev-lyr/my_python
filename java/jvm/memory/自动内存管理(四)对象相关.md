# 一 对象内存布局:
## (1)区域:
- 对象头(Header)
- 实例数据(Instance Data)
- 对齐填充(Padding)

## (2)对象头:
- 存储对象运行时数据: 哈希码(HashCode)、GC分代年龄、锁状态标识、线程持有的锁、偏向线程ID等, 这部分数据长度在32位虚拟机上为32bit, 64位上为64bit.
- 类型指针: 对象指向它的类元数据的指针, 虚拟机通过这个指针来确定对象是哪个类的实例.

## (3)实例数据:
- 对象真正存储的有效信息, 即代码中定义的各种类型的字段内容.

## (4)对齐填充:
- 占位符, HotSpot要求对象的起始地址必须为8字节的整数倍.

# 二 对象创建:
## (1)过程:
- 虚拟机遇到new指令, 首先检查指定参数是否能在常量池中定位到一个类的符号引用，并检查该类是否被加载、解析和初始化, 若没有则加载类.
- 类加载检查通过后, 虚拟机为新生对象分配内存, 将分配的内存空间初始化为零值(不包括对象头).
- 调用<init>函数根据代码对对象进行初始化, 至此真正可用对象产生出来.

## (2)内存分配方法:
- 指针碰撞: 假设堆中内存是绝对完整, 未使用的一边, 已使用一边, 中间放一个指针作为分界点的指示器, 分配时仅仅将指针向空闲段挪动一段和对象大小相等的距离.
- 空闲列表: 堆中内存是不规整的, 虚拟机必须维护一个列表记录哪些内存可用，在分配时选择一个足够大的空间划分给对象.
- 备注: 选择哪种方法依据垃圾收集器是否带有压缩整理功能, 例如: Serial, ParNew等收集器, 系统采用指针碰撞, CMS这种则使用空闲列表方法.

## (3)TLAB(Thread Local Allocation Buffer):
- 每个线程在堆中预先分配一块内存, 成为本地线程分配缓冲, 线程需要为对象分配内存时首先在自己的TLAB上分配, 只有TLAB用完才向对申请需分配新的TLAB.
- 通过-XX:+/-UseTLAB来设定线程是否使用TLAB.

## (4)备注:
- 指针碰撞时采用CAS保证在并发时候更新操作的原子性.

# 三 对象访问方法:
## (1)概述:
- Java程序通过栈上的reference数据来操作堆上对象.
- 虚拟机规范没有定义这个引用如何去定位和访问堆中对象的具体位置, 所以访问方式取决于虚拟机的实现.

## (2)主流方式:
- 使用句柄: 堆中划分一块内存作为句柄池, reference存放的是对象的句柄地址, 而句柄中包含了对象实例数据和类型数据的具体地址信息.
- 直接指针访问: reference直接存放对象地址, 对象的内存布局中存放它的类型相关信息的访问方式.
- 备注: 句柄方式好处reference中存储的是稳定句柄地址, 对象被移动时只会变更句柄中的实例数据指针; 直接指针方式: 速度更快, 节省了一次指针定位的开销.
- 备注: HotSpot采用直接指针方式.