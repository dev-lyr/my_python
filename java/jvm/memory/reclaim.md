# 一 概念：
## (1)垃圾回收功能：
- 分配内存.
- 保证被引用对象保留在内存.
- 释放不再被应用对象的内存.

## (2)垃圾回收收集器性能标准：
- 吞吐量
- 垃圾回收开销
- 暂停时间
- 收集的频繁度
- 等等.

## (3)备注：
- http://www.oracle.com/technetwork/java/javase/tech/index-jsp-140228.html.
- http://docs.oracle.com/javase/8/docs/technotes/guides/vm/gctuning/index.html
- https://docs.oracle.com/javase/8/docs/technotes/tools/windows/java.html

## 二 哪些对象需要回收:
## (1)引用计数:
- 存在循环引用问题, 主流JVM没有使用该方法.

## (2)根搜索算法(GC Roots Tracing):
- 主流使用可达性分析来判断对象是否存活.
- **思路**: 通过一系列成为GC Roots的对象作为**起始点**, 向下搜索, 搜索所走的路径成为**引用链**(Reference Chain), 当一个对象到GC Roots没有任何引用链则说明该对象是不可用的(可回收).
- **可作为GC Roots的对象类型**: 虚拟机栈中引用的对象, 类静态属性引用的变量, 常量引用的对象、JNI引用的对象.

## (3)是否死亡:
- 在可达性分析中不可达的对象处于缓刑阶段, 此时会判断对象是否需要执行finalize方法, 若对象没有覆盖finalize方法或finalize方法已经被虚拟机调过, 则认为没有必要执行.
- 若对象需要执行finalize方法则将该对象放入F-Queue队列, 稍后由虚拟机创建的一个低优先级线程来执行它, 这里只保证调用了finalize方法不保证会执行成功, 因为若执行缓慢或死循环则影响其它对象回收.
- 对象的finalize方法中可将自己重新连接到一个GC Roots对象, 从而救活自己免于被回收.
- 对象只会执行一次finalize方法，即只有一次自救机会.

## (4)方法区回收(永久代):
- JVM规范不要求JVM实现方法区的垃圾收集，因为在方法区回收的性价比比较低.
- 方法区回收主要回收: 废弃的常量和无用的类.
- 判断无用的类: 该类所有实例都被回收; 加载该类的ClassLoader已被回收; 该类对应的Class对象没有在任何地方被引用，无法在任何地方通过反射访问该类的方法.

## 三 垃圾回收算法.
## (1)标记-清除(Mark-Sweep):
- 过程:首先标记需回收的所有对象(即判断对象是否存活); 标记完成后统一回收.
- 缺点: 效率问题(标记和清除效率都不高); 空间问题(产生大量内存碎片).

## (2)复制算法:
- 将新生代内存划分为一个Eden空间和两块Survivor空间, 每次使用Eden和一块Survivor空间, 当回收时将Eden和Survivor中还存活的对象复制到另外一个Survivor区域.
- HotSpot默认Eden:Survivor大小为8:1.
- 当Survivor空间不足以保存存活对象时, 需依赖老年代的分配担保.

## (3)标记-整理(Mark-Compact):
- 与标记-清除类似，只是移动存活对象到一端, 然后清理掉其它部分内存, **减少内存碎片**.

## (4)分代收集(Generational Collection):
- 将Java堆分为**新生代和老年代**，然后根据各年代特点选择适当的**收集算法**.
- 新生代: 每次回收有大量对象死去, 只有少量存活, 则选用复制算法, 较少的复制成本就可以完成收集.
- 老年代: 对象存活率高, 没有额外空间分配担保, 必须使用标记-清理或标记-整理算法.

