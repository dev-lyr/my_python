# 一 概述:
## (1)定义:
- Java字节码(Class文件):是Java虚拟机的指令集合.
- Java虚拟机指令:由操作码(opcode, 一个字节长度)和紧跟其后的0个或多个操作数(operands)构成.
- Java虚拟机采用面向栈而不是寄存器的的架构，依赖操作数栈进行工作，操作数很少使用.

## (2)操作码:
- Java虚拟机限制操作码长度为1字节，因此操作码综述不能超过256个.

## (3)操作数:
- 操作数的数量和大小由操作码决定，许多操作码没有操作数.
- Class字节码文件没有对操作数进行长度对齐，因此对于超过一个字节的数据，必须在运行时重建出具体的数据结构.
- 优点:省去了一些填充和间隔符号；缺点：损失了一定的性能.

## (4)基于操作数栈(operand stack)的指令集:
- 优点:可移植，寄存器由硬件直接提供，程序不直接使用，由虚拟机自行决定把一些常访问数据放到寄存器中；代码紧凑；编译器实现简单.
- 缺点:完成相同功能比基于寄存器的指令集需要指令数量多；操作数栈是在内存中，需要访问内存，是性能瓶颈.

# 二 加载(load)和存储(store)指令:
## (1)功能:
- 在局部变量和操作数栈间转换值.

# 三 算术指令(Arithmetic):
## (1)功能:
- 通常是计算两个在操作数栈上的值, 并把计算结果存回操作数栈.

# 四 类型转换指令(Type Conversion):
## (1)功能:
- 允许Java虚拟机中数字类型间类型转换.

# 五 对象创建和操作:
## (1)功能:
- 用来创建和操作对象, 虽然类实例和数组都是对象, 但是JVM使用不同的指令来创建和操作对象和数组.

## (2)类实例相关:
- 创建类实例: new
- 访问类静态属性: getstatic, putstatic
- 访问类实例属性: getfield, putfield
- 检查类实例属性: instanceof, checkcast.

## (3)数组相关:
- 创建数组: newarray, anewarray, multianewarray.
- 获取数组长度: arraylength

# 六 操作数栈管理:
## (1)相关指令:
- pop, dup等.

# 七 控制转换指令:
## (1)功能:
- 条件或非条件性导致JVM继续执行其它的指令, 而不是控制流中的接下来的指令.

## (2)条件分支:
- ifeq, ifne等.

## (3)非条件分支:
- goto, goto_w, jsr等.

# 八 方法调用和返回指令:
## (1)调用方法的5个指令:
- invokevirtual: 调用一个对象的实例方法, java编程中通常的方法调用.
- invokeinterface: 调用一个接口的方法, 通过运行时特定对象来搜索该方法的实现.
- invokespecial: 调用一个实例用来进行特殊处理的方法, 例如: 对象初始化方法(<init>), 私有方法或超类方法.
- invokestatic: 调用命名类的类方法.
- invokedynamic.

## (2)返回指令:
- 方法返回指令根据返回类型区分, 例如:ireturn, lreturn, fretrun等.
- return指令从返回类型为void的函数返回.

# 九 抛出异常:
## (1)概述:
- 异常可以通过athrow指令显式抛出.
- 异常也可能被其它JVM指令检测到不正常条件时抛出.

# 十 同步:
## (1)概述:
- JVM支持方法级别和指令序列(同步块)级别的同步, 通过一个同步结构体:monitor来支持.

## (2)方法级别同步:
- 方法级别的同步是隐式的, 作为方法调用和返回的一部分, synchronized方法通过运行时常量池中method_info结构中的ACC_SYNCHRONIZED标记来识别, 在方法调用时检查.
- 当调用一个ACC_SYNCHRONIZED标记的方法, 执行线程会获得该monitor, 当调用正常结束或终止时退出该monitor.
- 当执行时, 当前线程拥有该monitor.

## (3)同步块:
- 指令序列的同步用来支持Java中的同步块, 相关指令: monitorenter和monitorexit.